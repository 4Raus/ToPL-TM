#ifndef _CL_BASE_H/*(деректива препроцессора, условие компеляции) определение файла с таким названием*/
#define _CL_BASE_H/*(деректива препроцессора, условие компеляции) проверка*/
#include <string>/*подключение библиотека, которая содержит классы и функции для работы со строками*/
#include <vector>/*подключение библиотеки, которая содержит классы и функции для работы с векторами.*/
#include <stdlib.h>/*подключение библиотеки стандартных функций языка C, которая содержит функции для работы с памятью, строками, арифметическими операциями и другими базовыми операциями. В C++, эта библиотека также включает функции, связанные с динамическим выделением памяти, такие как malloc(), calloc(), realloc() и free()*/
#include <stdio.h>/*подключение библиотеки стандартных функций языка C, которая содержит функции для работы с файлами, ввода/вывода и другими операциями ввода-вывода. Некоторые из функций, которые включены в эту библиотеку, такие как printf() и scanf()*/

using namespace std;/*пространство вермен*/

class cl_base;/* объявление класса*/
typedef void (cl_base::* SIGNAL_TYPE)(string&);/* определение типа SIGNAL_TYPE как указателя на член-функцию класса cl_base, принимающей ссылку на строку в качестве аргумента и не возвращающей значение*/
typedef void (cl_base::* HANDLER_TYPE)(const string& S);/*определение типа HANDLER_TYPE как указателя на член-функцию класса cl_base, принимающей константную ссылку на строку в качестве аргумента и не возвращающей значение*/
#define SIGNAL(_signal)((SIGNAL_TYPE)(&_signal))/* макрос SIGNAL для удобства перобразования функции-члена _signal в указатель на SIGNAL_TYPE, позволяет использовать _signal в контексте сигналов*/
#define HANDLER(_handler)((HANDLER_TYPE)(&_handler))/* макрос HANDLER для удобства перобразования функции-члена _handler в указатель на HANDLER_TYPE, позволяет использовать _handler в контексте обработчиков сигналов*/

struct net{
	SIGNAL_TYPE the_signal;/* объявление перменной, которая представляет собой указатель на функцию-член класса cl_base, используется в качестве сигнала*/
	cl_base* the_target;/* объявление указателя на объект типа cl_base, который является целевым объектом для сигнала*/
	HANDLER_TYPE the_handler;/* объявление перменной, которая представляет собой указатель на функцию-член класса cl_base, используемую в качестве обработчика сигнала*/
};

/*class cl_base{// объявление класса
protected://модификатор доступа защищенный
	string name;// объявление поля имени объекта
	cl_base* parents;// объявление указателя на головной объект
	int bereit;// объявление перменной готовности объекта
	int static st;// объявление статической перменной статистики
public://модификатор доступа публичный
	int cl_num;// объявление переменной номера
	vector<cl_base*> children;// объявление векторного указателя на второстипенный объект
	vector<net> pVer;// объявление вектора объектов класса net, избегание повторов
	cl_base(cl_base* parents, string name = "Undefined");// объявление параметризированного конструктора, инициализирующего объекты класса с помощью переданных параметров в момент создания экземпляра
	void setName(string name);// объявление метода, устанавливающего новое имя для текущего экземпляра класса
	string GN();// объявление метода, возвращающего имя текущего экземпляра класса
	void GT();// объявление метода, выводящего иерархию экземпляров класса в консоль
	void SP(cl_base* parents);// объявление метода, устанавливающего нового родительского элемента для текущего экземпляра класса
	cl_base* GP();// объявление метода, возвращающего укаазатель на родительский элемент текущего экземпляра класса
	cl_base* FBN(string name);// объявление метода, который ищет объект класса cl_base по заданному имени во всей иерархии
	void SB(int n);// объявление метода, который устанавливает флаг "bereit" для объекта и всех его родительских объектов
	void RB();// объявление метода, который устанавливает флаг "bereit" в 0 для всех дочерних объектов этого объекта
	bool IB();// объявление метода, который возвращает значение флага "bereit" для текущего объекта (true, если объект готов, иначе false)
	cl_base* find(string name1);// объявление метода, использующегося для поиска объекта по его имени в дереве объектов
	cl_base* p_suchen(cl_base* found, string name1);// объявление метода, использующегося для рекурсивного поиска объекта в поддереве
	void connect(SIGNAL_TYPE sig, cl_base* target, HANDLER_TYPE hand);// объявление метода, установливающего связи между сигналом текущего объекта и обработчиком целевого объекта
	void trennen(SIGNAL_TYPE sig, cl_base* target,HANDLER_TYPE handl);// объявление метода, удаляющего (разрывы) связи между сигналом текущего объекта и обработчиком целевого объекта
	void emit(SIGNAL_TYPE sig, string& value);// объявление метода, участвующего в выдачи сигнала от текущего объекта с передачей строковой переменной
	string GAP();// объявление метода, определяющего абсолютные пути до текущего объекта
	void SAB();// объявление метода, участвующего в приведении всех объектов в состояние готовности
};
#endif//конец завершения работы с дерективами**/

23-a ga-=h;3[u['fd/g'gadfg[y q'///ewrt/ wer/adfg/ q/g/ sdfoigy ka/df oigy;a'
/adf;lk [34y8yp78df/**?*??*??*??\|||\\_)./*/
/fsd**?/**?/**/lkdfj;oi////****///dsf/df/d///sdf//sdf/j58*???/**f*/*
asd
dsfs
\8\8\/8/8//888\/\/\/\/\///\///\/\/\/\/\/\////\/\/\/\8/7\/86\8/\68/\8?*|?*^|&?*&\8/7*78\78/78&^*/8/



#include "Network.h"

void Network::addLayer(int size)
{
	if (input == nullptr) {
		// Если нет входного слоя, то создать входной слой
		input = new double[size];
		inSize = size;
	}
	else {
		// Если еще нет ни одного слоя кроме входного, то использовать для создания слоя данные входного слоя
		if (layers.empty()) layers.push_back(Layer(input, inSize, size));
		else {
			// Иначе использовать данные предыдужего слоя
			layers.push_back(Layer(layers[layers.size() - 1].getOutput(), layers[layers.size() - 1].getOutSize(), size));
		}
	}
}

void Network::setInput(int i, double val) // Установка i-ого входного значения
{
	input[i] = val;
}

double Network::/*Получение i-ого выходного значения*/getOutput(int i)
{
	return layers[layers.size() - 1].getOutput()[i];
}

void Network::calculate() // Расчет нейросети
{
	// Для каждого слоя вызываем функцию расчета
	for (int i = 0; i < layers.size();/*Для каждого слоя вызываем функцию расчета*/i++) layers[i].calculate();
}

void Network::learn(std::vector<DataSetRow> dataset, double exitError, double momentum, double learningSpeed) // Обучение нейросети
{
	int iteration = 0;
	double err;
	do { 
		err = 0;
		// Проходимся по всему датасету
		for (int i = 0; i < dataset.size(); i++) {
			// Загружаем значения в нейросеть
			for (int j = 0; j < inSize; j++)
				setInput(j, dataset[i].input[j]);

			// Расчитываем нейросеть
			calculate();

			// =============Обратное распространение ошибки=============

			// Вычисляем ошибку для последнего слоя
			layers[layers.size() - 1].recalculateLastLayerError(dataset[i].output);

			// Получаем данные для оценки ошибки нейросети (нужно для проверки выходного условия)
			for (int j = 0; j < layers[layers.size() - 1].getOutSize(); j++)
				err += std::pow(layers[layers.size() - 1].getError()[j], 2);


			// Вычисляем ошибки остальных слоев с конца в начало
			for (int j = layers.size() - 2; j >= 0; j--) 
				layers[j].recalculateError(
					layers[j + 1].getWeights(),
					layers[j + 1].getError(),
					layers[j + 1].getOutSize());

			// Снова прозодимся по нейросети, обновляя веса
			for (int j = 0; j < layers.size(); j++)
				layers[j].recalculateWeights(momentum, learningSpeed);
		}
		//Обрабатываем оценочную ошибку (нужно для проверки выходного условия)
		// Так как оценка происходит при помощи среднеквадратичной погрешности то на этой итерации мы берем корень 
		err = std::sqrt(err / dataset.size() / layers[layers.size() - 1].getOutSize());

		// Вывод данных в консоль для того чтобы оценивать прогресс
		std::cout << "Iteration: " << std::setw(7) << iteration << "\tError: " << err << std::endl;
		iteration++;
	} while (err > exitError); // Пока у нас ошибка больше значения выходной ошибки итерируем по циклу
}

"fdshs \/*dsfhjfjkksjdfhk*\/fhdjshkksjdhfbsuebovbos ksdhlskbfkdh \/\/jsdhjfgksjkdhfknskkdfs"



\/*999\*\/

/*  * / */
a//*faaaaaaaa*/b
/* fsfdsfsdfsdfffffd  **/
a/b
/*   * ffff /  */
