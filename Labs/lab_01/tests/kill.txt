/*  * / */
a//*faaaaaaaa*/b
/* fsfdsfsdfsdfffffd  **/
a/b
/*   * ffff /  */


#ifndef _CL_BASE_H/*(деректива препроцессора, условие компеляции) определение файла с таким названием*/
#define _CL_BASE_H/*(деректива препроцессора, условие компеляции) проверка*/
#include <string>/*подключение библиотека, которая содержит классы и функции для работы со строками*/
#include <vector>/*подключение библиотеки, которая содержит классы и функции для работы с векторами.*/
#include <stdlib.h>/*подключение библиотеки стандартных функций языка C, которая содержит функции для работы с памятью, строками, арифметическими операциями и другими базовыми операциями. В C++, эта библиотека также включает функции, связанные с динамическим выделением памяти, такие как malloc(), calloc(), realloc() и free()*/
#include <stdio.h>/*подключение библиотеки стандартных функций языка C, которая содержит функции для работы с файлами, ввода/вывода и другими операциями ввода-вывода. Некоторые из функций, которые включены в эту библиотеку, такие как printf() и scanf()*/

using namespace std;/*пространство вермен*/

class cl_base;/* объявление класса*/
typedef void (cl_base::* SIGNAL_TYPE)(string&);/* определение типа SIGNAL_TYPE как указателя на член-функцию класса cl_base, принимающей ссылку на строку в качестве аргумента и не возвращающей значение*/
typedef void (cl_base::* HANDLER_TYPE)(const string& S);/*определение типа HANDLER_TYPE как указателя на член-функцию класса cl_base, принимающей константную ссылку на строку в качестве аргумента и не возвращающей значение*/
#define SIGNAL(_signal)((SIGNAL_TYPE)(&_signal))/* макрос SIGNAL для удобства перобразования функции-члена _signal в указатель на SIGNAL_TYPE, позволяет использовать _signal в контексте сигналов*/
#define HANDLER(_handler)((HANDLER_TYPE)(&_handler))/* макрос HANDLER для удобства перобразования функции-члена _handler в указатель на HANDLER_TYPE, позволяет использовать _handler в контексте обработчиков сигналов*/

struct net{
	SIGNAL_TYPE the_signal;/* объявление перменной, которая представляет собой указатель на функцию-член класса cl_base, используется в качестве сигнала*/
	cl_base* the_target;/* объявление указателя на объект типа cl_base, который является целевым объектом для сигнала*/
	HANDLER_TYPE the_handler;/* объявление перменной, которая представляет собой указатель на функцию-член класса cl_base, используемую в качестве обработчика сигнала*/
};

/*class cl_base{// объявление класса
protected://модификатор доступа защищенный
	string name;// объявление поля имени объекта
	cl_base* parents;// объявление указателя на головной объект
	int bereit;// объявление перменной готовности объекта
	int static st;// объявление статической перменной статистики
public://модификатор доступа публичный
	int cl_num;// объявление переменной номера
	vector<cl_base*> children;// объявление векторного указателя на второстипенный объект
	vector<net> pVer;// объявление вектора объектов класса net, избегание повторов
	cl_base(cl_base* parents, string name = "Undefined");// объявление параметризированного конструктора, инициализирующего объекты класса с помощью переданных параметров в момент создания экземпляра
	void setName(string name);// объявление метода, устанавливающего новое имя для текущего экземпляра класса
	string GN();// объявление метода, возвращающего имя текущего экземпляра класса
	void GT();// объявление метода, выводящего иерархию экземпляров класса в консоль
	void SP(cl_base* parents);// объявление метода, устанавливающего нового родительского элемента для текущего экземпляра класса
	cl_base* GP();// объявление метода, возвращающего укаазатель на родительский элемент текущего экземпляра класса
	cl_base* FBN(string name);// объявление метода, который ищет объект класса cl_base по заданному имени во всей иерархии
	void SB(int n);// объявление метода, который устанавливает флаг "bereit" для объекта и всех его родительских объектов
	void RB();// объявление метода, который устанавливает флаг "bereit" в 0 для всех дочерних объектов этого объекта
	bool IB();// объявление метода, который возвращает значение флага "bereit" для текущего объекта (true, если объект готов, иначе false)
	cl_base* find(string name1);// объявление метода, использующегося для поиска объекта по его имени в дереве объектов
	cl_base* p_suchen(cl_base* found, string name1);// объявление метода, использующегося для рекурсивного поиска объекта в поддереве
	void connect(SIGNAL_TYPE sig, cl_base* target, HANDLER_TYPE hand);// объявление метода, установливающего связи между сигналом текущего объекта и обработчиком целевого объекта
	void trennen(SIGNAL_TYPE sig, cl_base* target,HANDLER_TYPE handl);// объявление метода, удаляющего (разрывы) связи между сигналом текущего объекта и обработчиком целевого объекта
	void emit(SIGNAL_TYPE sig, string& value);// объявление метода, участвующего в выдачи сигнала от текущего объекта с передачей строковой переменной
	string GAP();// объявление метода, определяющего абсолютные пути до текущего объекта
	void SAB();// объявление метода, участвующего в приведении всех объектов в состояние готовности
};
#endif//конец завершения работы с дерективами**/

23-a ga-=h;3[u['fd/g'gadfg[y q'///ewrt/ wer/adfg/ q/g/ sdfoigy ka/df oigy;a'
/adf;lk [34y8yp78df/**?*??*??*??\|||\\_)./*/
/fsd**?/**?/**/lkdfj;oi////****///dsf/df/d///sdf//sdf/j58*???/**f*/*
asd
dsfs
\8\8\/8/8//888\/\/\/\/\///\///\/\/\/\/\/\////\/\/\/\8/7\/86\8/\68/\8?*|?*^|&?*&\8/7*78\78/78&^*/8/

